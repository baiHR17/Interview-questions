1. 输入两个有序array，输出合并array的中位数
    转变为寻找切分点的问题，譬如：
        arr1: 1, 3, 8, 9, 15
        arr2: 7, 11, 18, 19, 21, 25
    我们的目的是在arr1/2上面分别寻找一个切分点，使得两个切分点左右的数一样多。
    并且满足：左上的数小于等于右下的数，左下的数小于等于右上的数。
    由于要求数一样多，实际上就是寻找一个切分点，所以用二分查找，结果是log(min(m, n))

2. 求链表的中位数
    快慢指针，一个每次走一步，一个每次走两步

3. 最大子串和
    0 - i的最大子串和要么是arr[i], 要么是终止于i - 1的子串+arr[i]

4. 一个横竖都是顺序的矩阵，铺平之后第k小的元素
    用一个minheap,不断往里面添加所有元素，如果装多于k个就pop,最后pop。

5. 快排
    选定一个pivot之后，用两个指针一个从头到尾一个反着遍历，如果一个<pivot一个>pivot就交换位置，最后把pivot跟小的换位置。
    最后对i（小的指针）左边和右边进行sort

6. 反转链表
    用递归

7. 求根号
    二分法：根号2，从[0, 2]开始，看中点的值的平方和2进行比较
    切线法，根号2就是y = x^2 - 2和x轴的交点坐标，对于每一个点求导得到切线公式，求切线和x轴的交点，用交点往前进。

8 股票买卖时间
    不断追踪并更新当前出现的最小值和当前的最大收益。

9. 2Sum
    只有一个sol: 用一个hashmap,每段check target - cur在不在里面
    不止一个sol: 先排序，然后两个指针一左一右，如果和大了就右指针左移，反之左指针右移，如果等于就同时移一下。

10. 出现频率最高的K个元素
    桶，先遍历一遍得到元素和次数的hashmap并记录最大的出现次数，然后构建一个ArrayList[]，长度为最大的次数，在遍历一次把元素
    装到对应出现次数的index下面。

11. 出现频率最高的K个单词
    先遍历一遍，得到一个包含单词和出现次数的hashmap，然后构建一个priorityqueue，往里面offer（java可以传入comparator覆盖比较方法）
    如果size大于k就poll

12. 无重复字串
    滑动窗口，左右端ij从0开始，不断问j在不在set，如果在的话就i++，不在的话就把j装进去然后j++，res = max(res, j - i)

13. 判断BST
    迭代的判断，用一个helper function每次除了root之外还要传入一个max和min value


